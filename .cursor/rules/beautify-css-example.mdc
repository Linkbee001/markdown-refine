---
description:
globs:
alwaysApply: false
---
# CSS 美化器实现示例

本文档提供了 CSS 美化器的详细实现指南和最佳实践。

## 核心功能

CSS 美化器应具备以下核心功能：

1. **CSS 格式化**：重新格式化 CSS 代码，包括缩进、空格和换行
2. **CSS 压缩**：移除不必要的空白和注释以减小文件大小
3. **属性排序**：按照预定义的顺序对 CSS 属性进行排序
4. **错误检测**：标识和报告 CSS 语法错误
5. **前缀处理**：自动添加或移除浏览器兼容前缀

## 美化配置选项

```javascript
const defaultCssBeautifyOptions = {
  indent: '  ',            // 缩进字符串，可以是空格或制表符
  openbrace: 'end-of-line', // 开括号位置 ('separate-line', 'end-of-line')
  autosemicolon: false,    // 是否在属性末尾插入分号
  sortProperties: false,   // 是否对属性进行排序
  sortOrder: 'alphabetical', // 排序顺序 ('alphabetical', 'grouped')
  preserveComments: true,  // 是否保留注释
  indentSize: 2,           // 缩进大小（如果使用空格）
  maxLineLength: 80,       // 每行最大长度
  compressOutput: false,   // 是否压缩输出
  includeEmptyLines: true, // 是否包含空行
};
```

## 示例实现

```javascript
import cssBeautify from 'css-beautify';
import autoprefixer from 'autoprefixer';
import postcss from 'postcss';

/**
 * CSS 美化处理函数
 * @param {string} css - 原始 CSS 代码
 * @param {Object} options - 美化选项
 * @returns {Promise<string>} - 美化后的 CSS 代码
 */
export async function beautifyCss(css, options = {}) {
  // 合并默认选项和用户选项
  const mergedOptions = { ...defaultCssBeautifyOptions, ...options };
  
  try {
    let result = css;
    
    // 1. 使用 PostCSS 进行处理（如果需要前缀处理）
    if (options.autoPrefix) {
      const postcssResult = await postcss([
        autoprefixer({ overrideBrowserslist: options.browsers || ['> 1%', 'last 2 versions'] })
      ]).process(css, { from: undefined });
      
      result = postcssResult.css;
    }
    
    // 2. 格式化 CSS
    if (!options.compressOutput) {
      result = cssBeautify(result, {
        indent: mergedOptions.indent.repeat(mergedOptions.indentSize),
        openbrace: mergedOptions.openbrace,
        autosemicolon: mergedOptions.autosemicolon,
      });
      
      // 3. 属性排序（可选）
      if (mergedOptions.sortProperties) {
        result = sortCssProperties(result, mergedOptions.sortOrder);
      }
    } else {
      // 如果是压缩模式，则移除所有不必要的空白和注释
      result = compressCss(result, mergedOptions.preserveComments);
    }
    
    return result;
  } catch (error) {
    // 错误处理
    console.error('CSS 美化失败:', error);
    throw new Error(`CSS 美化失败: ${error.message}`);
  }
}

/**
 * CSS 属性排序函数
 * @param {string} css - CSS 代码
 * @param {string} sortOrder - 排序顺序
 * @returns {string} - 排序后的 CSS 代码
 */
function sortCssProperties(css, sortOrder) {
  // 这里实现 CSS 属性排序逻辑
  // 略...
  
  return css;
}

/**
 * CSS 压缩函数
 * @param {string} css - CSS 代码
 * @param {boolean} preserveComments - 是否保留注释
 * @returns {string} - 压缩后的 CSS 代码
 */
function compressCss(css, preserveComments) {
  // 这里实现 CSS 压缩逻辑
  // 略...
  
  return css;
}
```

## React 组件实现

```jsx
import React, { useState } from 'react';
import { beautifyCss } from '../utils/css-beautifier';
import { Button, Checkbox, Input, Select, Slider } from '../components/ui';
import { useTranslation } from '../i18n';

const CssBeautifier = () => {
  const { t } = useTranslation();
  const [cssInput, setCssInput] = useState('');
  const [beautifiedCss, setBeautifiedCss] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [options, setOptions] = useState({
    indentSize: 2,
    openbrace: 'end-of-line',
    autosemicolon: false,
    sortProperties: false,
    sortOrder: 'alphabetical',
    preserveComments: true,
    compressOutput: false,
    autoPrefix: true,
    browsers: ['> 1%', 'last 2 versions'],
  });

  const handleOptionChange = (option, value) => {
    setOptions({ ...options, [option]: value });
  };

  const handleBeautify = async () => {
    if (!cssInput.trim()) return;

    setIsProcessing(true);
    try {
      const result = await beautifyCss(cssInput, options);
      setBeautifiedCss(result);
    } catch (error) {
      console.error(error);
      // 使用国际化处理错误信息
      alert(t('cssBeautifier.errors.processingFailed', { error: error.message }));
    } finally {
      setIsProcessing(false);
    }
  };

  const handleCopyResult = () => {
    navigator.clipboard.writeText(beautifiedCss);
    // 使用国际化处理提示信息
    alert(t('cssBeautifier.messages.copied'));
  };

  return (
    <div className="css-beautifier">
      <h1>{t('cssBeautifier.title')}</h1>
      <p>{t('cssBeautifier.description')}</p>

      <div className="options-panel">
        <div className="option-group">
          <h3>{t('cssBeautifier.optionsTitle')}</h3>
          
          <div className="option">
            <label>{t('cssBeautifier.options.indentSize')}</label>
            <Select
              value={options.indentSize}
              onChange={(value) => handleOptionChange('indentSize', value)}
              options={[2, 4, 8].map(size => ({ label: size, value: size }))}
            />
          </div>
          
          <div className="option">
            <label>{t('cssBeautifier.options.openBrace')}</label>
            <Select
              value={options.openbrace}
              onChange={(value) => handleOptionChange('openbrace', value)}
              options={[
                { label: t('cssBeautifier.options.openBraceOptions.endOfLine'), value: 'end-of-line' },
                { label: t('cssBeautifier.options.openBraceOptions.separateLine'), value: 'separate-line' }
              ]}
            />
          </div>
          
          <div className="option">
            <label>{t('cssBeautifier.options.autoSemicolon')}</label>
            <Checkbox
              checked={options.autosemicolon}
              onChange={(e) => handleOptionChange('autosemicolon', e.target.checked)}
            />
          </div>
          
          <div className="option">
            <label>{t('cssBeautifier.options.sortProperties')}</label>
            <Checkbox
              checked={options.sortProperties}
              onChange={(e) => handleOptionChange('sortProperties', e.target.checked)}
            />
          </div>
          
          {options.sortProperties && (
            <div className="option">
              <label>{t('cssBeautifier.options.sortOrder')}</label>
              <Select
                value={options.sortOrder}
                onChange={(value) => handleOptionChange('sortOrder', value)}
                options={[
                  { label: t('cssBeautifier.options.sortOrderOptions.alphabetical'), value: 'alphabetical' },
                  { label: t('cssBeautifier.options.sortOrderOptions.grouped'), value: 'grouped' }
                ]}
              />
            </div>
          )}
          
          <div className="option">
            <label>{t('cssBeautifier.options.compressOutput')}</label>
            <Checkbox
              checked={options.compressOutput}
              onChange={(e) => handleOptionChange('compressOutput', e.target.checked)}
            />
          </div>
          
          <div className="option">
            <label>{t('cssBeautifier.options.autoPrefix')}</label>
            <Checkbox
              checked={options.autoPrefix}
              onChange={(e) => handleOptionChange('autoPrefix', e.target.checked)}
            />
          </div>
        </div>
      </div>

      <div className="input-output-container">
        <div className="input-panel">
          <h3>{t('cssBeautifier.inputTitle')}</h3>
          <Input.TextArea
            value={cssInput}
            onChange={(e) => setCssInput(e.target.value)}
            placeholder={t('cssBeautifier.placeholders.input')}
            rows={15}
          />
        </div>
        
        <div className="actions">
          <Button 
            onClick={handleBeautify} 
            disabled={isProcessing || !cssInput.trim()}
            loading={isProcessing}
            type="primary"
          >
            {t('cssBeautifier.actions.beautify')}
          </Button>
          
          <Button onClick={() => setCssInput('')}>
            {t('cssBeautifier.actions.clearInput')}
          </Button>
          
          {beautifiedCss && (
            <Button onClick={handleCopyResult}>
              {t('cssBeautifier.actions.copy')}
            </Button>
          )}
        </div>
        
        {beautifiedCss && (
          <div className="output-panel">
            <h3>{t('cssBeautifier.outputTitle')}</h3>
            <pre className="beautified-css">{beautifiedCss}</pre>
          </div>
        )}
      </div>
    </div>
  );
};

export default CssBeautifier;
```

## 翻译示例

```javascript
// zh-CN.js
export default {
  cssBeautifier: {
    title: 'CSS 美化器',
    description: '格式化和优化您的 CSS 代码',
    optionsTitle: '美化选项',
    inputTitle: '输入 CSS',
    outputTitle: '美化后的 CSS',
    options: {
      indentSize: '缩进大小',
      openBrace: '开括号位置',
      openBraceOptions: {
        endOfLine: '行尾',
        separateLine: '单独一行'
      },
      autoSemicolon: '自动分号',
      sortProperties: '属性排序',
      sortOrder: '排序方式',
      sortOrderOptions: {
        alphabetical: '字母顺序',
        grouped: '分组排序'
      },
      preserveComments: '保留注释',
      compressOutput: '压缩输出',
      autoPrefix: '自动添加前缀'
    },
    actions: {
      beautify: '美化',
      clearInput: '清空输入',
      copy: '复制结果'
    },
    placeholders: {
      input: '在此粘贴您的 CSS 代码...'
    },
    messages: {
      copied: '已复制到剪贴板！'
    },
    errors: {
      processingFailed: '处理失败: {error}'
    }
  }
}

// en-US.js
export default {
  cssBeautifier: {
    title: 'CSS Beautifier',
    description: 'Format and optimize your CSS code',
    optionsTitle: 'Beautify Options',
    inputTitle: 'Input CSS',
    outputTitle: 'Beautified CSS',
    options: {
      indentSize: 'Indent Size',
      openBrace: 'Open Brace Position',
      openBraceOptions: {
        endOfLine: 'End of Line',
        separateLine: 'Separate Line'
      },
      autoSemicolon: 'Auto Semicolon',
      sortProperties: 'Sort Properties',
      sortOrder: 'Sort Order',
      sortOrderOptions: {
        alphabetical: 'Alphabetical',
        grouped: 'Grouped'
      },
      preserveComments: 'Preserve Comments',
      compressOutput: 'Compress Output',
      autoPrefix: 'Auto Prefix'
    },
    actions: {
      beautify: 'Beautify',
      clearInput: 'Clear Input',
      copy: 'Copy Result'
    },
    placeholders: {
      input: 'Paste your CSS code here...'
    },
    messages: {
      copied: 'Copied to clipboard!'
    },
    errors: {
      processingFailed: 'Processing failed: {error}'
    }
  }
}
```

## 最佳实践

1. **模块化设计**
   - 分离核心美化逻辑和 UI 组件
   - 使用工具函数处理特定任务

2. **错误处理**
   - 捕获并优雅处理所有可能的错误
   - 提供有意义的错误消息

3. **性能优化**
   - 对大型 CSS 文件使用异步处理
   - 实现防抖以避免频繁处理

4. **可访问性**
   - 确保所有控件都可通过键盘访问
   - 提供充分的颜色对比度

5. **国际化**
   - 所有文本使用翻译键
   - 支持错误消息的国际化
